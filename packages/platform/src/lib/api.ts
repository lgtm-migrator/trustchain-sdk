/* tslint:disable */
/* eslint-disable */
/**
 * Platform interaction
 * Explore the functionality of the platform
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccountInformation
 */
export interface AccountInformation {
    /**
     * 
     * @type {string}
     * @memberof AccountInformation
     */
    'prename': string;
    /**
     * 
     * @type {string}
     * @memberof AccountInformation
     */
    'surname': string;
}
/**
 * 
 * @export
 * @interface Contract
 */
export interface Contract {
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'message': string;
    /**
     * 
     * @type {Array<Participant>}
     * @memberof Contract
     */
    'participants': Array<Participant>;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'repeat'?: ContractRepeat;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'nextRepeat'?: string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    '_id': string;
    /**
     * 
     * @type {User}
     * @memberof Contract
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'file': string;
    /**
     * 
     * @type {string}
     * @memberof Contract
     */
    'createdAt': string;
}

export const ContractRepeat = {
    daily: 'daily',
    weekly: 'weekly',
    monthly: 'monthly'
} as const;

export type ContractRepeat = typeof ContractRepeat[keyof typeof ContractRepeat];

/**
 * 
 * @export
 * @interface ContractInput
 */
export interface ContractInput {
    /**
     * 
     * @type {string}
     * @memberof ContractInput
     */
    'fieldType': string;
    /**
     * 
     * @type {string}
     * @memberof ContractInput
     */
    'value': string;
    /**
     * 
     * @type {number}
     * @memberof ContractInput
     */
    'id'?: number;
}
/**
 * 
 * @export
 * @interface ContractMetaData
 */
export interface ContractMetaData {
    /**
     * 
     * @type {Array<Field>}
     * @memberof ContractMetaData
     */
    'fields'?: Array<Field>;
    /**
     * 
     * @type {UserContract}
     * @memberof ContractMetaData
     */
    'user': UserContract;
}
/**
 * 
 * @export
 * @interface ContractTemplate
 */
export interface ContractTemplate {
    /**
     * 
     * @type {string}
     * @memberof ContractTemplate
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof ContractTemplate
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof ContractTemplate
     */
    '_id': string;
    /**
     * 
     * @type {User}
     * @memberof ContractTemplate
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof ContractTemplate
     */
    'file': string;
    /**
     * 
     * @type {Array<Stakeholder>}
     * @memberof ContractTemplate
     */
    'participants': Array<Stakeholder>;
    /**
     * 
     * @type {string}
     * @memberof ContractTemplate
     */
    'createdAt': string;
}
/**
 * 
 * @export
 * @interface CreateContractDto
 */
export interface CreateContractDto {
    /**
     * 
     * @type {string}
     * @memberof CreateContractDto
     */
    'subject': string;
    /**
     * 
     * @type {string}
     * @memberof CreateContractDto
     */
    'message': string;
    /**
     * 
     * @type {string}
     * @memberof CreateContractDto
     */
    'host': string;
    /**
     * 
     * @type {string}
     * @memberof CreateContractDto
     */
    'repeat'?: CreateContractDtoRepeat;
    /**
     * 
     * @type {string}
     * @memberof CreateContractDto
     */
    'file': string;
    /**
     * 
     * @type {string}
     * @memberof CreateContractDto
     */
    'name'?: string;
    /**
     * 
     * @type {Array<ContractMetaData>}
     * @memberof CreateContractDto
     */
    'metaData': Array<ContractMetaData>;
    /**
     * 
     * @type {string}
     * @memberof CreateContractDto
     */
    'image'?: string;
}

export const CreateContractDtoRepeat = {
    daily: 'daily',
    weekly: 'weekly',
    monthly: 'monthly'
} as const;

export type CreateContractDtoRepeat = typeof CreateContractDtoRepeat[keyof typeof CreateContractDtoRepeat];

/**
 * 
 * @export
 * @interface CreateContractResponse
 */
export interface CreateContractResponse {
    /**
     * 
     * @type {string}
     * @memberof CreateContractResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof CreateContractResponse
     */
    'secret'?: string;
}
/**
 * 
 * @export
 * @interface CreateCredentialDto
 */
export interface CreateCredentialDto {
    /**
     * 
     * @type {string}
     * @memberof CreateCredentialDto
     */
    'did': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCredentialDto
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCredentialDto
     */
    'user': string;
    /**
     * 
     * @type {string}
     * @memberof CreateCredentialDto
     */
    'verifier': string;
}
/**
 * 
 * @export
 * @interface CreateFeedbackDto
 */
export interface CreateFeedbackDto {
    /**
     * 
     * @type {string}
     * @memberof CreateFeedbackDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface CreateInputDto
 */
export interface CreateInputDto {
    /**
     * 
     * @type {string}
     * @memberof CreateInputDto
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof CreateInputDto
     */
    'file': string;
}
/**
 * 
 * @export
 * @interface CreateTemplate
 */
export interface CreateTemplate {
    /**
     * 
     * @type {string}
     * @memberof CreateTemplate
     */
    'file': string;
    /**
     * 
     * @type {string}
     * @memberof CreateTemplate
     */
    'name'?: string;
    /**
     * 
     * @type {Array<ContractMetaData>}
     * @memberof CreateTemplate
     */
    'metaData': Array<ContractMetaData>;
    /**
     * 
     * @type {string}
     * @memberof CreateTemplate
     */
    'image'?: string;
}
/**
 * 
 * @export
 * @interface Credential
 */
export interface Credential {
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    '_id': string;
    /**
     * 
     * @type {Template}
     * @memberof Credential
     */
    'template': Template;
    /**
     * 
     * @type {User}
     * @memberof Credential
     */
    'user': User;
    /**
     * 
     * @type {object}
     * @memberof Credential
     */
    'values': object;
    /**
     * 
     * @type {string}
     * @memberof Credential
     */
    'deleted': string;
}
/**
 * 
 * @export
 * @interface DashboardResponse
 */
export interface DashboardResponse {
    /**
     * 
     * @type {number}
     * @memberof DashboardResponse
     */
    'contractsOpen': number;
    /**
     * 
     * @type {number}
     * @memberof DashboardResponse
     */
    'contractsFinished': number;
    /**
     * 
     * @type {number}
     * @memberof DashboardResponse
     */
    'todo': number;
    /**
     * 
     * @type {number}
     * @memberof DashboardResponse
     */
    'signed': number;
}
/**
 * 
 * @export
 * @interface DeclineContractDto
 */
export interface DeclineContractDto {
    /**
     * 
     * @type {string}
     * @memberof DeclineContractDto
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof DeclineContractDto
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface DelegateContractDto
 */
export interface DelegateContractDto {
    /**
     * 
     * @type {string}
     * @memberof DelegateContractDto
     */
    'secret': string;
    /**
     * 
     * @type {string}
     * @memberof DelegateContractDto
     */
    'user': string;
}
/**
 * 
 * @export
 * @interface EndPointResponse
 */
export interface EndPointResponse {
    /**
     * 
     * @type {string}
     * @memberof EndPointResponse
     */
    'own': string;
    /**
     * 
     * @type {object}
     * @memberof EndPointResponse
     */
    'networks': object;
}
/**
 * 
 * @export
 * @interface Field
 */
export interface Field {
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    'id': number;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'type': FieldType;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'userId': string;
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    'x': number;
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    'y': number;
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    'width': number;
    /**
     * 
     * @type {number}
     * @memberof Field
     */
    'height': number;
    /**
     * 
     * @type {string}
     * @memberof Field
     */
    'value'?: string;
}

export const FieldType = {
    signature: 'signature',
    initials: 'initials',
    qr: 'qr',
    name: 'name',
    town: 'town',
    date: 'date',
    locationDate: 'locationDate',
    text: 'text'
} as const;

export type FieldType = typeof FieldType[keyof typeof FieldType];

/**
 * 
 * @export
 * @interface FileResponse
 */
export interface FileResponse {
    /**
     * 
     * @type {string}
     * @memberof FileResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface FileUploadResponse
 */
export interface FileUploadResponse {
    /**
     * 
     * @type {string}
     * @memberof FileUploadResponse
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface ImageResponse
 */
export interface ImageResponse {
    /**
     * 
     * @type {string}
     * @memberof ImageResponse
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface ImagesResponse
 */
export interface ImagesResponse {
    /**
     * 
     * @type {string}
     * @memberof ImagesResponse
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ImagesResponse
     */
    'url': string;
    /**
     * 
     * @type {string}
     * @memberof ImagesResponse
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof ImagesResponse
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Information
 */
export interface Information {
    /**
     * 
     * @type {string}
     * @memberof Information
     */
    'prename'?: string;
    /**
     * 
     * @type {string}
     * @memberof Information
     */
    'surname'?: string;
}
/**
 * 
 * @export
 * @interface Input
 */
export interface Input {
    /**
     * 
     * @type {User}
     * @memberof Input
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof Input
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Input
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface JobRequest
 */
export interface JobRequest {
    /**
     * 
     * @type {object}
     * @memberof JobRequest
     */
    'transaction': object;
    /**
     * 
     * @type {string}
     * @memberof JobRequest
     */
    'endpoint': string;
}
/**
 * 
 * @export
 * @interface KeyPair
 */
export interface KeyPair {
    /**
     * 
     * @type {string}
     * @memberof KeyPair
     */
    'identifier': string;
    /**
     * 
     * @type {object}
     * @memberof KeyPair
     */
    'publicKey': object;
    /**
     * 
     * @type {string}
     * @memberof KeyPair
     */
    'privateKey': string;
    /**
     * 
     * @type {SignatureType}
     * @memberof KeyPair
     */
    'signatureType': SignatureType;
}
/**
 * 
 * @export
 * @interface LoginDto
 */
export interface LoginDto {
    /**
     * 
     * @type {string}
     * @memberof LoginDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof LoginDto
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface MailCredentialDto
 */
export interface MailCredentialDto {
    /**
     * 
     * @type {string}
     * @memberof MailCredentialDto
     */
    'html': string;
    /**
     * 
     * @type {string}
     * @memberof MailCredentialDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof MailCredentialDto
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface Participant
 */
export interface Participant {
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'role': ParticipantRole;
    /**
     * 
     * @type {Array<ContractInput>}
     * @memberof Participant
     */
    'values'?: Array<ContractInput>;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'secret'?: string;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'signed'?: string;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'declined'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Participant
     */
    'unsub': boolean;
    /**
     * 
     * @type {Array<SignEvent>}
     * @memberof Participant
     */
    'events': Array<SignEvent>;
    /**
     * 
     * @type {string}
     * @memberof Participant
     */
    'userId': string;
    /**
     * 
     * @type {Array<Field>}
     * @memberof Participant
     */
    'fields'?: Array<Field>;
}

export const ParticipantRole = {
    signer: 'signer',
    cc: 'cc',
    system: 'system'
} as const;

export type ParticipantRole = typeof ParticipantRole[keyof typeof ParticipantRole];

/**
 * 
 * @export
 * @interface PdfRequest
 */
export interface PdfRequest {
    /**
     * 
     * @type {string}
     * @memberof PdfRequest
     */
    'html': string;
}
/**
 * 
 * @export
 * @interface PostCredential
 */
export interface PostCredential {
    /**
     * 
     * @type {object}
     * @memberof PostCredential
     */
    'values': object;
}
/**
 * 
 * @export
 * @interface PushKey
 */
export interface PushKey {
    /**
     * 
     * @type {string}
     * @memberof PushKey
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface PushSubKeys
 */
export interface PushSubKeys {
    /**
     * 
     * @type {string}
     * @memberof PushSubKeys
     */
    'p256dh': string;
    /**
     * 
     * @type {string}
     * @memberof PushSubKeys
     */
    'auth': string;
}
/**
 * 
 * @export
 * @interface PushSubscription
 */
export interface PushSubscription {
    /**
     * 
     * @type {string}
     * @memberof PushSubscription
     */
    'endpoint': string;
    /**
     * 
     * @type {number}
     * @memberof PushSubscription
     */
    'expirationTime': number;
    /**
     * 
     * @type {PushSubKeys}
     * @memberof PushSubscription
     */
    'keys': PushSubKeys;
}
/**
 * 
 * @export
 * @interface PushUnsubscribe
 */
export interface PushUnsubscribe {
    /**
     * 
     * @type {string}
     * @memberof PushUnsubscribe
     */
    'endpoint': string;
}
/**
 * 
 * @export
 * @interface RegisterDto
 */
export interface RegisterDto {
    /**
     * username of the account
     * @type {string}
     * @memberof RegisterDto
     */
    'username': string;
    /**
     * random encoded buffer that is used for salting
     * @type {string}
     * @memberof RegisterDto
     */
    'salt'?: string;
    /**
     * 
     * @type {RegistryRolesDto}
     * @memberof RegisterDto
     */
    'roles'?: RegistryRolesDto;
}
/**
 * 
 * @export
 * @interface RegistryRolesDto
 */
export interface RegistryRolesDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof RegistryRolesDto
     */
    'roles': Array<RegistryRolesDtoRoles>;
    /**
     * 
     * @type {string}
     * @memberof RegistryRolesDto
     */
    'hash': string;
}

export const RegistryRolesDtoRoles = {
    admin: 'admin',
    contract: 'contract',
    contract_issuer: 'contract.issuer',
    credential: 'credential',
    training: 'training',
    training_consultant: 'training.consultant',
    training_taxConsultant: 'training.taxConsultant',
    training_manager: 'training.manager',
    manager: 'manager',
    member: 'member'
} as const;

export type RegistryRolesDtoRoles = typeof RegistryRolesDtoRoles[keyof typeof RegistryRolesDtoRoles];

/**
 * 
 * @export
 * @interface RequestLinkDto
 */
export interface RequestLinkDto {
    /**
     * 
     * @type {string}
     * @memberof RequestLinkDto
     */
    'username': string;
}
/**
 * 
 * @export
 * @interface S3FileResponse
 */
export interface S3FileResponse {
    /**
     * 
     * @type {string}
     * @memberof S3FileResponse
     */
    'url': string;
}
/**
 * 
 * @export
 * @interface SaltResponse
 */
export interface SaltResponse {
    /**
     * 
     * @type {string}
     * @memberof SaltResponse
     */
    'value': string;
}
/**
 * 
 * @export
 * @interface SignContractDto
 */
export interface SignContractDto {
    /**
     * 
     * @type {string}
     * @memberof SignContractDto
     */
    'secret': string;
    /**
     * 
     * @type {Array<ContractInput>}
     * @memberof SignContractDto
     */
    'fields': Array<ContractInput>;
}
/**
 * 
 * @export
 * @interface SignEvent
 */
export interface SignEvent {
    /**
     * 
     * @type {string}
     * @memberof SignEvent
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof SignEvent
     */
    'type': SignEventType;
}

export const SignEventType = {
    opened: 'opened',
    signed: 'signed',
    viewed: 'viewed',
    mailOpened: 'mailOpened',
    unsub: 'unsub',
    delegated: 'delegated',
    declined: 'declined'
} as const;

export type SignEventType = typeof SignEventType[keyof typeof SignEventType];

/**
 * 
 * @export
 * @enum {string}
 */

export const SignatureType = {
    RSA: 'RSA',
    BBS: 'BBS+'
} as const;

export type SignatureType = typeof SignatureType[keyof typeof SignatureType];


/**
 * 
 * @export
 * @interface Stakeholder
 */
export interface Stakeholder {
    /**
     * 
     * @type {string}
     * @memberof Stakeholder
     */
    'userId': string;
    /**
     * 
     * @type {Array<Field>}
     * @memberof Stakeholder
     */
    'fields'?: Array<Field>;
}
/**
 * 
 * @export
 * @interface Template
 */
export interface Template {
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'did': string;
    /**
     * 
     * @type {User}
     * @memberof Template
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof Template
     */
    'verifier': string;
}
/**
 * 
 * @export
 * @interface Training
 */
export interface Training {
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'type': string;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'date': string;
    /**
     * 
     * @type {number}
     * @memberof Training
     */
    'duration': number;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'notice': string;
    /**
     * 
     * @type {boolean}
     * @memberof Training
     */
    'specific'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'random': string;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'fileId': string;
    /**
     * 
     * @type {User}
     * @memberof Training
     */
    'user': User;
    /**
     * 
     * @type {string}
     * @memberof Training
     */
    'hash': string;
}
/**
 * 
 * @export
 * @interface UnsubContractDto
 */
export interface UnsubContractDto {
    /**
     * 
     * @type {string}
     * @memberof UnsubContractDto
     */
    'secret': string;
}
/**
 * 
 * @export
 * @interface UpdatePasswordDto
 */
export interface UpdatePasswordDto {
    /**
     * old password
     * @type {string}
     * @memberof UpdatePasswordDto
     */
    'oldPassword': string;
    /**
     * new password
     * @type {string}
     * @memberof UpdatePasswordDto
     */
    'newPassword': string;
    /**
     * new encrypted key
     * @type {string}
     * @memberof UpdatePasswordDto
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {Array<UserRole>}
     * @memberof User
     */
    'roles': Array<UserRole>;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    '_id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'salt': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'key': string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'verified': boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'deleted': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastLogin': string;
    /**
     * 
     * @type {Information}
     * @memberof User
     */
    'information': Information;
    /**
     * 
     * @type {Wallet}
     * @memberof User
     */
    'did': Wallet;
    /**
     * 
     * @type {Array<PushSubscription>}
     * @memberof User
     */
    'pushSubs': Array<PushSubscription>;
    /**
     * 
     * @type {UserView}
     * @memberof User
     */
    'userView': UserView;
    /**
     * 
     * @type {User}
     * @memberof User
     */
    'manager'?: User;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'inactive': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'tutorial': Array<string>;
}
/**
 * 
 * @export
 * @interface UserContract
 */
export interface UserContract {
    /**
     * 
     * @type {string}
     * @memberof UserContract
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserContract
     */
    'role': UserContractRole;
}

export const UserContractRole = {
    signer: 'signer',
    cc: 'cc',
    system: 'system'
} as const;

export type UserContractRole = typeof UserContractRole[keyof typeof UserContractRole];

/**
 * 
 * @export
 * @interface UserCreateDto
 */
export interface UserCreateDto {
    /**
     * prename
     * @type {string}
     * @memberof UserCreateDto
     */
    'prename'?: string;
    /**
     * surname
     * @type {string}
     * @memberof UserCreateDto
     */
    'surname'?: string;
    /**
     * username that the user uses to register
     * @type {string}
     * @memberof UserCreateDto
     */
    'username': string;
    /**
     * name of the manager that is responsible for this account
     * @type {string}
     * @memberof UserCreateDto
     */
    'manager'?: string;
    /**
     * 
     * @type {Array<UserRole>}
     * @memberof UserCreateDto
     */
    'roles': Array<UserRole>;
}
/**
 * 
 * @export
 * @interface UserExport
 */
export interface UserExport {
    /**
     * 
     * @type {string}
     * @memberof UserExport
     */
    'username': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserExport
     */
    'verified': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserExport
     */
    'instructions': Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UserRole = {
    admin: 'admin',
    contract: 'contract',
    contract_issuer: 'contract.issuer',
    credential: 'credential',
    training: 'training',
    training_consultant: 'training.consultant',
    training_taxConsultant: 'training.taxConsultant',
    training_manager: 'training.manager',
    manager: 'manager',
    member: 'member'
} as const;

export type UserRole = typeof UserRole[keyof typeof UserRole];


/**
 * 
 * @export
 * @interface UserView
 */
export interface UserView {
    /**
     * 
     * @type {Array<string>}
     * @memberof UserView
     */
    'tableSettingsUser': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserView
     */
    'tableSettingsUserMobile': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserView
     */
    'tableSettingsHr': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserView
     */
    'tableSettingsHrMobile': Array<string>;
}
/**
 * 
 * @export
 * @interface VerifyDto
 */
export interface VerifyDto {
    /**
     * 
     * @type {string}
     * @memberof VerifyDto
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyDto
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyDto
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof VerifyDto
     */
    'key': string;
}
/**
 * 
 * @export
 * @interface Wallet
 */
export interface Wallet {
    /**
     * 
     * @type {Array<KeyPair>}
     * @memberof Wallet
     */
    'wallet': Array<KeyPair>;
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    'id': string;
}

/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Activate a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerActivate: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerActivate', 'id', id)
            const localVarPath = `/accounts/{id}/activate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create a user by adding an identifier to an username.
         * @param {UserCreateDto} userCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerCreate: async (userCreateDto: UserCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreateDto' is not null or undefined
            assertParamExists('accountsControllerCreate', 'userCreateDto', userCreateDto)
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deactivate a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerDeactivate: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerDeactivate', 'id', id)
            const localVarPath = `/accounts/{id}/deactivate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerDelete', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all user names and their manager.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns one specific user.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerGetOne', 'id', id)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates a reset token for the password.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerResetPassword: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerResetPassword', 'id', id)
            const localVarPath = `/accounts/{id}/reset`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update a user entity.
         * @param {string} id 
         * @param {UserCreateDto} userCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerUpdate: async (id: string, userCreateDto: UserCreateDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('accountsControllerUpdate', 'id', id)
            // verify required parameter 'userCreateDto' is not null or undefined
            assertParamExists('accountsControllerUpdate', 'userCreateDto', userCreateDto)
            const localVarPath = `/accounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreateDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Activate a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerActivate(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerActivate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create a user by adding an identifier to an username.
         * @param {UserCreateDto} userCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerCreate(userCreateDto: UserCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerCreate(userCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deactivate a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerDeactivate(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerDeactivate(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all user names and their manager.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns one specific user.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerGetOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerGetOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates a reset token for the password.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerResetPassword(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerResetPassword(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update a user entity.
         * @param {string} id 
         * @param {UserCreateDto} userCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountsControllerUpdate(id: string, userCreateDto: UserCreateDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accountsControllerUpdate(id, userCreateDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * 
         * @summary Activate a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerActivate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.accountsControllerActivate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create a user by adding an identifier to an username.
         * @param {UserCreateDto} userCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerCreate(userCreateDto: UserCreateDto, options?: any): AxiosPromise<void> {
            return localVarFp.accountsControllerCreate(userCreateDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deactivate a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerDeactivate(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.accountsControllerDeactivate(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a user
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.accountsControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all user names and their manager.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetAll(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.accountsControllerGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns one specific user.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerGetOne(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.accountsControllerGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates a reset token for the password.
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerResetPassword(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.accountsControllerResetPassword(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update a user entity.
         * @param {string} id 
         * @param {UserCreateDto} userCreateDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountsControllerUpdate(id: string, userCreateDto: UserCreateDto, options?: any): AxiosPromise<void> {
            return localVarFp.accountsControllerUpdate(id, userCreateDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * 
     * @summary Activate a user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerActivate(id: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerActivate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create a user by adding an identifier to an username.
     * @param {UserCreateDto} userCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerCreate(userCreateDto: UserCreateDto, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerCreate(userCreateDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deactivate a user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerDeactivate(id: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerDeactivate(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a user
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerDelete(id: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all user names and their manager.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerGetAll(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns one specific user.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerGetOne(id: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates a reset token for the password.
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerResetPassword(id: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerResetPassword(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update a user entity.
     * @param {string} id 
     * @param {UserCreateDto} userCreateDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public accountsControllerUpdate(id: string, userCreateDto: UserCreateDto, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).accountsControllerUpdate(id, userCreateDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthorizeApi - axios parameter creator
 * @export
 */
export const AuthorizeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Updates the password.
         * @param {UpdatePasswordDto} updatePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerChangePassword: async (updatePasswordDto: UpdatePasswordDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updatePasswordDto' is not null or undefined
            assertParamExists('authControllerChangePassword', 'updatePasswordDto', updatePasswordDto)
            const localVarPath = `/auth/change_password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePasswordDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary deletes the own account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerDeleteAccount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs a user into the system based on the auth guard
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin: async (loginDto: LoginDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginDto' is not null or undefined
            assertParamExists('authControllerLogin', 'loginDto', loginDto)
            const localVarPath = `/auth/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary registers a new account
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister: async (registerDto: RegisterDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerDto' is not null or undefined
            assertParamExists('authControllerRegister', 'registerDto', registerDto)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sends an email to reset the password
         * @param {RequestLinkDto} requestLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRequestLink: async (requestLinkDto: RequestLinkDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestLinkDto' is not null or undefined
            assertParamExists('authControllerRequestLink', 'requestLinkDto', requestLinkDto)
            const localVarPath = `/auth/request`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestLinkDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the salt of a user.
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSalt: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('authControllerSalt', 'username', username)
            const localVarPath = `/auth/salt/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Sets a password for the account. Token required that was generated during registration
         * @param {VerifyDto} verifyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerify: async (verifyDto: VerifyDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'verifyDto' is not null or undefined
            assertParamExists('authControllerVerify', 'verifyDto', verifyDto)
            const localVarPath = `/auth/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(verifyDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizeApi - functional programming interface
 * @export
 */
export const AuthorizeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorizeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Updates the password.
         * @param {UpdatePasswordDto} updatePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerChangePassword(updatePasswordDto: UpdatePasswordDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerChangePassword(updatePasswordDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary deletes the own account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerDeleteAccount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerDeleteAccount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logs a user into the system based on the auth guard
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerLogin(loginDto: LoginDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerLogin(loginDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary registers a new account
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRegister(registerDto: RegisterDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRegister(registerDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sends an email to reset the password
         * @param {RequestLinkDto} requestLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerRequestLink(requestLinkDto: RequestLinkDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerRequestLink(requestLinkDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the salt of a user.
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerSalt(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaltResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerSalt(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Sets a password for the account. Token required that was generated during registration
         * @param {VerifyDto} verifyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authControllerVerify(verifyDto: VerifyDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authControllerVerify(verifyDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthorizeApi - factory interface
 * @export
 */
export const AuthorizeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorizeApiFp(configuration)
    return {
        /**
         * 
         * @summary Updates the password.
         * @param {UpdatePasswordDto} updatePasswordDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerChangePassword(updatePasswordDto: UpdatePasswordDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerChangePassword(updatePasswordDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary deletes the own account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerDeleteAccount(options?: any): AxiosPromise<void> {
            return localVarFp.authControllerDeleteAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logs a user into the system based on the auth guard
         * @param {LoginDto} loginDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerLogin(loginDto: LoginDto, options?: any): AxiosPromise<LoginResponse> {
            return localVarFp.authControllerLogin(loginDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary registers a new account
         * @param {RegisterDto} registerDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRegister(registerDto: RegisterDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerRegister(registerDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sends an email to reset the password
         * @param {RequestLinkDto} requestLinkDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerRequestLink(requestLinkDto: RequestLinkDto, options?: any): AxiosPromise<object> {
            return localVarFp.authControllerRequestLink(requestLinkDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the salt of a user.
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerSalt(username: string, options?: any): AxiosPromise<SaltResponse> {
            return localVarFp.authControllerSalt(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Sets a password for the account. Token required that was generated during registration
         * @param {VerifyDto} verifyDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authControllerVerify(verifyDto: VerifyDto, options?: any): AxiosPromise<void> {
            return localVarFp.authControllerVerify(verifyDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorizeApi - object-oriented interface
 * @export
 * @class AuthorizeApi
 * @extends {BaseAPI}
 */
export class AuthorizeApi extends BaseAPI {
    /**
     * 
     * @summary Updates the password.
     * @param {UpdatePasswordDto} updatePasswordDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizeApi
     */
    public authControllerChangePassword(updatePasswordDto: UpdatePasswordDto, options?: AxiosRequestConfig) {
        return AuthorizeApiFp(this.configuration).authControllerChangePassword(updatePasswordDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary deletes the own account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizeApi
     */
    public authControllerDeleteAccount(options?: AxiosRequestConfig) {
        return AuthorizeApiFp(this.configuration).authControllerDeleteAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logs a user into the system based on the auth guard
     * @param {LoginDto} loginDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizeApi
     */
    public authControllerLogin(loginDto: LoginDto, options?: AxiosRequestConfig) {
        return AuthorizeApiFp(this.configuration).authControllerLogin(loginDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary registers a new account
     * @param {RegisterDto} registerDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizeApi
     */
    public authControllerRegister(registerDto: RegisterDto, options?: AxiosRequestConfig) {
        return AuthorizeApiFp(this.configuration).authControllerRegister(registerDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sends an email to reset the password
     * @param {RequestLinkDto} requestLinkDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizeApi
     */
    public authControllerRequestLink(requestLinkDto: RequestLinkDto, options?: AxiosRequestConfig) {
        return AuthorizeApiFp(this.configuration).authControllerRequestLink(requestLinkDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the salt of a user.
     * @param {string} username 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizeApi
     */
    public authControllerSalt(username: string, options?: AxiosRequestConfig) {
        return AuthorizeApiFp(this.configuration).authControllerSalt(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Sets a password for the account. Token required that was generated during registration
     * @param {VerifyDto} verifyDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizeApi
     */
    public authControllerVerify(verifyDto: VerifyDto, options?: AxiosRequestConfig) {
        return AuthorizeApiFp(this.configuration).authControllerVerify(verifyDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BlockchainApi - axios parameter creator
 * @export
 */
export const BlockchainApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Returns the endpoints of the observer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainControllerEndpoints: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/blockchain/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Adds a transaction to the queue
         * @param {JobRequest} jobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainControllerJob: async (jobRequest: JobRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'jobRequest' is not null or undefined
            assertParamExists('blockchainControllerJob', 'jobRequest', jobRequest)
            const localVarPath = `/blockchain/job`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(jobRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockchainApi - functional programming interface
 * @export
 */
export const BlockchainApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BlockchainApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Returns the endpoints of the observer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockchainControllerEndpoints(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EndPointResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockchainControllerEndpoints(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Adds a transaction to the queue
         * @param {JobRequest} jobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockchainControllerJob(jobRequest: JobRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.blockchainControllerJob(jobRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BlockchainApi - factory interface
 * @export
 */
export const BlockchainApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BlockchainApiFp(configuration)
    return {
        /**
         * 
         * @summary Returns the endpoints of the observer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainControllerEndpoints(options?: any): AxiosPromise<EndPointResponse> {
            return localVarFp.blockchainControllerEndpoints(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Adds a transaction to the queue
         * @param {JobRequest} jobRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockchainControllerJob(jobRequest: JobRequest, options?: any): AxiosPromise<void> {
            return localVarFp.blockchainControllerJob(jobRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlockchainApi - object-oriented interface
 * @export
 * @class BlockchainApi
 * @extends {BaseAPI}
 */
export class BlockchainApi extends BaseAPI {
    /**
     * 
     * @summary Returns the endpoints of the observer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockchainApi
     */
    public blockchainControllerEndpoints(options?: AxiosRequestConfig) {
        return BlockchainApiFp(this.configuration).blockchainControllerEndpoints(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Adds a transaction to the queue
     * @param {JobRequest} jobRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockchainApi
     */
    public blockchainControllerJob(jobRequest: JobRequest, options?: AxiosRequestConfig) {
        return BlockchainApiFp(this.configuration).blockchainControllerJob(jobRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContractsApi - axios parameter creator
 * @export
 */
export const ContractsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {SignContractDto} signContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerAddSignature: async (id: string, signContractDto: SignContractDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerAddSignature', 'id', id)
            // verify required parameter 'signContractDto' is not null or undefined
            assertParamExists('contractsControllerAddSignature', 'signContractDto', signContractDto)
            const localVarPath = `/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signContractDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary returns the contacts to send the contract to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerContacts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts/contacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateContractDto} createContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerCreate: async (createContractDto: CreateContractDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createContractDto' is not null or undefined
            assertParamExists('contractsControllerCreate', 'createContractDto', createContractDto)
            const localVarPath = `/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createContractDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDashboard: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts/dashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {DeclineContractDto} declineContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDeclineContract: async (id: string, declineContractDto: DeclineContractDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerDeclineContract', 'id', id)
            // verify required parameter 'declineContractDto' is not null or undefined
            assertParamExists('contractsControllerDeclineContract', 'declineContractDto', declineContractDto)
            const localVarPath = `/contracts/{id}/decline`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(declineContractDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {DelegateContractDto} delegateContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDelegateContract: async (id: string, delegateContractDto: DelegateContractDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerDelegateContract', 'id', id)
            // verify required parameter 'delegateContractDto' is not null or undefined
            assertParamExists('contractsControllerDelegateContract', 'delegateContractDto', delegateContractDto)
            const localVarPath = `/contracts/{id}/delegate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(delegateContractDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary download a signed file with included fields
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDownloadPdfFile: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerDownloadPdfFile', 'id', id)
            const localVarPath = `/contracts/{id}/pdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [signId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerFindOne: async (id: string, signId?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerFindOne', 'id', id)
            const localVarPath = `/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (signId !== undefined) {
                localVarQueryParameter['signId'] = signId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerGetInputs: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts/inputs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerGetPixel: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerGetPixel', 'id', id)
            const localVarPath = `/contracts/mail/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerInbox: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts/inbox`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerOwn: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts/own`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerRemindContract: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerRemindContract', 'id', id)
            const localVarPath = `/contracts/{id}/remind`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerRemove: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerRemove', 'id', id)
            const localVarPath = `/contracts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateInputDto} createInputDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerSetInput: async (createInputDto: CreateInputDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createInputDto' is not null or undefined
            assertParamExists('contractsControllerSetInput', 'createInputDto', createInputDto)
            const localVarPath = `/contracts/input`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createInputDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UnsubContractDto} unsubContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerUnsubContract: async (id: string, unsubContractDto: UnsubContractDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('contractsControllerUnsubContract', 'id', id)
            // verify required parameter 'unsubContractDto' is not null or undefined
            assertParamExists('contractsControllerUnsubContract', 'unsubContractDto', unsubContractDto)
            const localVarPath = `/contracts/{id}/unsub`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(unsubContractDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContractsApi - functional programming interface
 * @export
 */
export const ContractsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContractsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {SignContractDto} signContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerAddSignature(id: string, signContractDto: SignContractDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerAddSignature(id, signContractDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary returns the contacts to send the contract to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerContacts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerContacts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateContractDto} createContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerCreate(createContractDto: CreateContractDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateContractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerCreate(createContractDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerDashboard(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DashboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerDashboard(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {DeclineContractDto} declineContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerDeclineContract(id: string, declineContractDto: DeclineContractDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerDeclineContract(id, declineContractDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {DelegateContractDto} delegateContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerDelegateContract(id: string, delegateContractDto: DelegateContractDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerDelegateContract(id, delegateContractDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary download a signed file with included fields
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerDownloadPdfFile(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerDownloadPdfFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [signId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerFindOne(id: string, signId?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerFindOne(id, signId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contract>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerGetInputs(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Input>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerGetInputs(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerGetPixel(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerGetPixel(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerInbox(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contract>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerInbox(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerOwn(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Contract>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerOwn(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerRemindContract(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerRemindContract(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerRemove(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerRemove(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateInputDto} createInputDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerSetInput(createInputDto: CreateInputDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerSetInput(createInputDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {UnsubContractDto} unsubContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsControllerUnsubContract(id: string, unsubContractDto: UnsubContractDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsControllerUnsubContract(id, unsubContractDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContractsApi - factory interface
 * @export
 */
export const ContractsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContractsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {SignContractDto} signContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerAddSignature(id: string, signContractDto: SignContractDto, options?: any): AxiosPromise<void> {
            return localVarFp.contractsControllerAddSignature(id, signContractDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary returns the contacts to send the contract to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerContacts(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.contractsControllerContacts(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateContractDto} createContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerCreate(createContractDto: CreateContractDto, options?: any): AxiosPromise<CreateContractResponse> {
            return localVarFp.contractsControllerCreate(createContractDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDashboard(options?: any): AxiosPromise<DashboardResponse> {
            return localVarFp.contractsControllerDashboard(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {DeclineContractDto} declineContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDeclineContract(id: string, declineContractDto: DeclineContractDto, options?: any): AxiosPromise<void> {
            return localVarFp.contractsControllerDeclineContract(id, declineContractDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {DelegateContractDto} delegateContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDelegateContract(id: string, delegateContractDto: DelegateContractDto, options?: any): AxiosPromise<void> {
            return localVarFp.contractsControllerDelegateContract(id, delegateContractDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary download a signed file with included fields
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerDownloadPdfFile(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.contractsControllerDownloadPdfFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} [signId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerFindOne(id: string, signId?: string, options?: any): AxiosPromise<Contract> {
            return localVarFp.contractsControllerFindOne(id, signId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerGet(options?: any): AxiosPromise<Array<Contract>> {
            return localVarFp.contractsControllerGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerGetInputs(options?: any): AxiosPromise<Array<Input>> {
            return localVarFp.contractsControllerGetInputs(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerGetPixel(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.contractsControllerGetPixel(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerInbox(options?: any): AxiosPromise<Array<Contract>> {
            return localVarFp.contractsControllerInbox(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerOwn(options?: any): AxiosPromise<Array<Contract>> {
            return localVarFp.contractsControllerOwn(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerRemindContract(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.contractsControllerRemindContract(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerRemove(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.contractsControllerRemove(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateInputDto} createInputDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerSetInput(createInputDto: CreateInputDto, options?: any): AxiosPromise<void> {
            return localVarFp.contractsControllerSetInput(createInputDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UnsubContractDto} unsubContractDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsControllerUnsubContract(id: string, unsubContractDto: UnsubContractDto, options?: any): AxiosPromise<void> {
            return localVarFp.contractsControllerUnsubContract(id, unsubContractDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContractsApi - object-oriented interface
 * @export
 * @class ContractsApi
 * @extends {BaseAPI}
 */
export class ContractsApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {SignContractDto} signContractDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerAddSignature(id: string, signContractDto: SignContractDto, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerAddSignature(id, signContractDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary returns the contacts to send the contract to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerContacts(options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerContacts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateContractDto} createContractDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerCreate(createContractDto: CreateContractDto, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerCreate(createContractDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerDashboard(options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerDashboard(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {DeclineContractDto} declineContractDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerDeclineContract(id: string, declineContractDto: DeclineContractDto, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerDeclineContract(id, declineContractDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {DelegateContractDto} delegateContractDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerDelegateContract(id: string, delegateContractDto: DelegateContractDto, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerDelegateContract(id, delegateContractDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary download a signed file with included fields
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerDownloadPdfFile(id: string, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerDownloadPdfFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} [signId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerFindOne(id: string, signId?: string, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerFindOne(id, signId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerGet(options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerGetInputs(options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerGetInputs(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerGetPixel(id: string, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerGetPixel(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerInbox(options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerInbox(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerOwn(options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerOwn(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerRemindContract(id: string, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerRemindContract(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerRemove(id: string, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerRemove(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateInputDto} createInputDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerSetInput(createInputDto: CreateInputDto, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerSetInput(createInputDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UnsubContractDto} unsubContractDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractsApi
     */
    public contractsControllerUnsubContract(id: string, unsubContractDto: UnsubContractDto, options?: AxiosRequestConfig) {
        return ContractsApiFp(this.configuration).contractsControllerUnsubContract(id, unsubContractDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CredentialsApi - axios parameter creator
 * @export
 */
export const CredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateCredentialDto} createCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerCreate: async (createCredentialDto: CreateCredentialDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCredentialDto' is not null or undefined
            assertParamExists('credentialsControllerCreate', 'createCredentialDto', createCredentialDto)
            const localVarPath = `/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCredentialDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerDeleteStore: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('credentialsControllerDeleteStore', 'id', id)
            const localVarPath = `/credentials/store/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerFindAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerFindOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('credentialsControllerFindOne', 'id', id)
            const localVarPath = `/credentials/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerGetStore: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('credentialsControllerGetStore', 'id', id)
            const localVarPath = `/credentials/store/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MailCredentialDto} mailCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerMail: async (mailCredentialDto: MailCredentialDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mailCredentialDto' is not null or undefined
            assertParamExists('credentialsControllerMail', 'mailCredentialDto', mailCredentialDto)
            const localVarPath = `/credentials/mail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(mailCredentialDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PostCredential} postCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerPutStore: async (id: string, postCredential: PostCredential, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('credentialsControllerPutStore', 'id', id)
            // verify required parameter 'postCredential' is not null or undefined
            assertParamExists('credentialsControllerPutStore', 'postCredential', postCredential)
            const localVarPath = `/credentials/store/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PdfRequest} pdfRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerToPdf: async (pdfRequest: PdfRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pdfRequest' is not null or undefined
            assertParamExists('credentialsControllerToPdf', 'pdfRequest', pdfRequest)
            const localVarPath = `/credentials/pdf`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pdfRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CredentialsApi - functional programming interface
 * @export
 */
export const CredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateCredentialDto} createCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsControllerCreate(createCredentialDto: CreateCredentialDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsControllerCreate(createCredentialDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsControllerDeleteStore(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsControllerDeleteStore(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsControllerFindAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsControllerFindAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsControllerFindOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Template>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsControllerFindOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsControllerGetStore(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Credential>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsControllerGetStore(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {MailCredentialDto} mailCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsControllerMail(mailCredentialDto: MailCredentialDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsControllerMail(mailCredentialDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {PostCredential} postCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsControllerPutStore(id: string, postCredential: PostCredential, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsControllerPutStore(id, postCredential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {PdfRequest} pdfRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsControllerToPdf(pdfRequest: PdfRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsControllerToPdf(pdfRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CredentialsApi - factory interface
 * @export
 */
export const CredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CredentialsApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateCredentialDto} createCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerCreate(createCredentialDto: CreateCredentialDto, options?: any): AxiosPromise<void> {
            return localVarFp.credentialsControllerCreate(createCredentialDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerDeleteStore(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.credentialsControllerDeleteStore(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerFindAll(options?: any): AxiosPromise<void> {
            return localVarFp.credentialsControllerFindAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerFindOne(id: string, options?: any): AxiosPromise<Template> {
            return localVarFp.credentialsControllerFindOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerGetStore(id: string, options?: any): AxiosPromise<Array<Credential>> {
            return localVarFp.credentialsControllerGetStore(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MailCredentialDto} mailCredentialDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerMail(mailCredentialDto: MailCredentialDto, options?: any): AxiosPromise<void> {
            return localVarFp.credentialsControllerMail(mailCredentialDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PostCredential} postCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerPutStore(id: string, postCredential: PostCredential, options?: any): AxiosPromise<void> {
            return localVarFp.credentialsControllerPutStore(id, postCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PdfRequest} pdfRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsControllerToPdf(pdfRequest: PdfRequest, options?: any): AxiosPromise<any> {
            return localVarFp.credentialsControllerToPdf(pdfRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CredentialsApi - object-oriented interface
 * @export
 * @class CredentialsApi
 * @extends {BaseAPI}
 */
export class CredentialsApi extends BaseAPI {
    /**
     * 
     * @param {CreateCredentialDto} createCredentialDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public credentialsControllerCreate(createCredentialDto: CreateCredentialDto, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).credentialsControllerCreate(createCredentialDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public credentialsControllerDeleteStore(id: string, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).credentialsControllerDeleteStore(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public credentialsControllerFindAll(options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).credentialsControllerFindAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public credentialsControllerFindOne(id: string, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).credentialsControllerFindOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public credentialsControllerGetStore(id: string, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).credentialsControllerGetStore(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MailCredentialDto} mailCredentialDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public credentialsControllerMail(mailCredentialDto: MailCredentialDto, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).credentialsControllerMail(mailCredentialDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PostCredential} postCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public credentialsControllerPutStore(id: string, postCredential: PostCredential, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).credentialsControllerPutStore(id, postCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PdfRequest} pdfRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public credentialsControllerToPdf(pdfRequest: PdfRequest, options?: AxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).credentialsControllerToPdf(pdfRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FeedbackApi - axios parameter creator
 * @export
 */
export const FeedbackApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {CreateFeedbackDto} createFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbackControllerStore: async (createFeedbackDto: CreateFeedbackDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createFeedbackDto' is not null or undefined
            assertParamExists('feedbackControllerStore', 'createFeedbackDto', createFeedbackDto)
            const localVarPath = `/feedback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createFeedbackDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedbackApi - functional programming interface
 * @export
 */
export const FeedbackApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FeedbackApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {CreateFeedbackDto} createFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async feedbackControllerStore(createFeedbackDto: CreateFeedbackDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.feedbackControllerStore(createFeedbackDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FeedbackApi - factory interface
 * @export
 */
export const FeedbackApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FeedbackApiFp(configuration)
    return {
        /**
         * 
         * @param {CreateFeedbackDto} createFeedbackDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        feedbackControllerStore(createFeedbackDto: CreateFeedbackDto, options?: any): AxiosPromise<void> {
            return localVarFp.feedbackControllerStore(createFeedbackDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FeedbackApi - object-oriented interface
 * @export
 * @class FeedbackApi
 * @extends {BaseAPI}
 */
export class FeedbackApi extends BaseAPI {
    /**
     * 
     * @param {CreateFeedbackDto} createFeedbackDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedbackApi
     */
    public feedbackControllerStore(createFeedbackDto: CreateFeedbackDto, options?: AxiosRequestConfig) {
        return FeedbackApiFp(this.configuration).feedbackControllerStore(createFeedbackDto, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FileApi - axios parameter creator
 * @export
 */
export const FileApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary download the pdf file
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileControllerDownloadFile: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('fileControllerDownloadFile', 'id', id)
            const localVarPath = `/file/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary upload a file
         * @param {any} file file that should be signed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileControllerUploadFile: async (file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('fileControllerUploadFile', 'file', file)
            const localVarPath = `/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FileApi - functional programming interface
 * @export
 */
export const FileApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FileApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary download the pdf file
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileControllerDownloadFile(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<S3FileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileControllerDownloadFile(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary upload a file
         * @param {any} file file that should be signed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileControllerUploadFile(file: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUploadResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileControllerUploadFile(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FileApi - factory interface
 * @export
 */
export const FileApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FileApiFp(configuration)
    return {
        /**
         * 
         * @summary download the pdf file
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileControllerDownloadFile(id: string, options?: any): AxiosPromise<S3FileResponse> {
            return localVarFp.fileControllerDownloadFile(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary upload a file
         * @param {any} file file that should be signed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileControllerUploadFile(file: any, options?: any): AxiosPromise<FileUploadResponse> {
            return localVarFp.fileControllerUploadFile(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FileApi - object-oriented interface
 * @export
 * @class FileApi
 * @extends {BaseAPI}
 */
export class FileApi extends BaseAPI {
    /**
     * 
     * @summary download the pdf file
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public fileControllerDownloadFile(id: string, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).fileControllerDownloadFile(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary upload a file
     * @param {any} file file that should be signed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FileApi
     */
    public fileControllerUploadFile(file: any, options?: AxiosRequestConfig) {
        return FileApiFp(this.configuration).fileControllerUploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ImageApi - axios parameter creator
 * @export
 */
export const ImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerGetAllImages: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerGetImageById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageControllerGetImageById', 'id', id)
            const localVarPath = `/image/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerRemoveImage: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageControllerRemoveImage', 'id', id)
            const localVarPath = `/image/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerShowImageById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imageControllerShowImageById', 'id', id)
            const localVarPath = `/image/{id}/show`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {any} file file that should be signed
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerUploadFile: async (file: any, name: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('imageControllerUploadFile', 'file', file)
            // verify required parameter 'name' is not null or undefined
            assertParamExists('imageControllerUploadFile', 'name', name)
            const localVarPath = `/image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImageApi - functional programming interface
 * @export
 */
export const ImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImageApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageControllerGetAllImages(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ImagesResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageControllerGetAllImages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageControllerGetImageById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageControllerGetImageById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageControllerRemoveImage(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageControllerRemoveImage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageControllerShowImageById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageControllerShowImageById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {any} file file that should be signed
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async imageControllerUploadFile(file: any, name: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imageControllerUploadFile(file, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ImageApi - factory interface
 * @export
 */
export const ImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImageApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerGetAllImages(options?: any): AxiosPromise<Array<ImagesResponse>> {
            return localVarFp.imageControllerGetAllImages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerGetImageById(id: string, options?: any): AxiosPromise<ImageResponse> {
            return localVarFp.imageControllerGetImageById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerRemoveImage(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.imageControllerRemoveImage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerShowImageById(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.imageControllerShowImageById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {any} file file that should be signed
         * @param {string} name 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        imageControllerUploadFile(file: any, name: string, options?: any): AxiosPromise<void> {
            return localVarFp.imageControllerUploadFile(file, name, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImageApi - object-oriented interface
 * @export
 * @class ImageApi
 * @extends {BaseAPI}
 */
export class ImageApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public imageControllerGetAllImages(options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).imageControllerGetAllImages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public imageControllerGetImageById(id: string, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).imageControllerGetImageById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public imageControllerRemoveImage(id: string, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).imageControllerRemoveImage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public imageControllerShowImageById(id: string, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).imageControllerShowImageById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {any} file file that should be signed
     * @param {string} name 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ImageApi
     */
    public imageControllerUploadFile(file: any, name: string, options?: AxiosRequestConfig) {
        return ImageApiFp(this.configuration).imageControllerUploadFile(file, name, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ManagerApi - axios parameter creator
 * @export
 */
export const ManagerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Gets a specific employer of a manager
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        managerControllerFindEmployee: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('managerControllerFindEmployee', 'id', id)
            const localVarPath = `/manager/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Gets all user from a manager
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        managerControllerFindEmployees: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/manager`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ManagerApi - functional programming interface
 * @export
 */
export const ManagerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ManagerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Gets a specific employer of a manager
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async managerControllerFindEmployee(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserExport>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.managerControllerFindEmployee(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Gets all user from a manager
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async managerControllerFindEmployees(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserExport>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.managerControllerFindEmployees(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ManagerApi - factory interface
 * @export
 */
export const ManagerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ManagerApiFp(configuration)
    return {
        /**
         * 
         * @summary Gets a specific employer of a manager
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        managerControllerFindEmployee(id: string, options?: any): AxiosPromise<UserExport> {
            return localVarFp.managerControllerFindEmployee(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Gets all user from a manager
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        managerControllerFindEmployees(options?: any): AxiosPromise<Array<UserExport>> {
            return localVarFp.managerControllerFindEmployees(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ManagerApi - object-oriented interface
 * @export
 * @class ManagerApi
 * @extends {BaseAPI}
 */
export class ManagerApi extends BaseAPI {
    /**
     * 
     * @summary Gets a specific employer of a manager
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagerApi
     */
    public managerControllerFindEmployee(id: string, options?: AxiosRequestConfig) {
        return ManagerApiFp(this.configuration).managerControllerFindEmployee(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Gets all user from a manager
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ManagerApi
     */
    public managerControllerFindEmployees(options?: AxiosRequestConfig) {
        return ManagerApiFp(this.configuration).managerControllerFindEmployees(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PushApi - axios parameter creator
 * @export
 */
export const PushApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary get the key of the endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushControllerGetKey: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/push`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary unsubscribe
         * @param {PushUnsubscribe} pushUnsubscribe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushControllerRemoveKey: async (pushUnsubscribe: PushUnsubscribe, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pushUnsubscribe' is not null or undefined
            assertParamExists('pushControllerRemoveKey', 'pushUnsubscribe', pushUnsubscribe)
            const localVarPath = `/push/unsub`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pushUnsubscribe, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary store the sub key
         * @param {PushSubscription} pushSubscription 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushControllerStoreKey: async (pushSubscription: PushSubscription, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pushSubscription' is not null or undefined
            assertParamExists('pushControllerStoreKey', 'pushSubscription', pushSubscription)
            const localVarPath = `/push/sub`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pushSubscription, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary test subs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushControllerTest: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/push/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PushApi - functional programming interface
 * @export
 */
export const PushApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PushApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary get the key of the endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushControllerGetKey(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PushKey>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushControllerGetKey(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary unsubscribe
         * @param {PushUnsubscribe} pushUnsubscribe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushControllerRemoveKey(pushUnsubscribe: PushUnsubscribe, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushControllerRemoveKey(pushUnsubscribe, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary store the sub key
         * @param {PushSubscription} pushSubscription 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushControllerStoreKey(pushSubscription: PushSubscription, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushControllerStoreKey(pushSubscription, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary test subs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushControllerTest(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushControllerTest(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PushApi - factory interface
 * @export
 */
export const PushApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PushApiFp(configuration)
    return {
        /**
         * 
         * @summary get the key of the endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushControllerGetKey(options?: any): AxiosPromise<PushKey> {
            return localVarFp.pushControllerGetKey(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary unsubscribe
         * @param {PushUnsubscribe} pushUnsubscribe 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushControllerRemoveKey(pushUnsubscribe: PushUnsubscribe, options?: any): AxiosPromise<void> {
            return localVarFp.pushControllerRemoveKey(pushUnsubscribe, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary store the sub key
         * @param {PushSubscription} pushSubscription 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushControllerStoreKey(pushSubscription: PushSubscription, options?: any): AxiosPromise<void> {
            return localVarFp.pushControllerStoreKey(pushSubscription, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary test subs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushControllerTest(options?: any): AxiosPromise<void> {
            return localVarFp.pushControllerTest(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PushApi - object-oriented interface
 * @export
 * @class PushApi
 * @extends {BaseAPI}
 */
export class PushApi extends BaseAPI {
    /**
     * 
     * @summary get the key of the endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushApi
     */
    public pushControllerGetKey(options?: AxiosRequestConfig) {
        return PushApiFp(this.configuration).pushControllerGetKey(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary unsubscribe
     * @param {PushUnsubscribe} pushUnsubscribe 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushApi
     */
    public pushControllerRemoveKey(pushUnsubscribe: PushUnsubscribe, options?: AxiosRequestConfig) {
        return PushApiFp(this.configuration).pushControllerRemoveKey(pushUnsubscribe, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary store the sub key
     * @param {PushSubscription} pushSubscription 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushApi
     */
    public pushControllerStoreKey(pushSubscription: PushSubscription, options?: AxiosRequestConfig) {
        return PushApiFp(this.configuration).pushControllerStoreKey(pushSubscription, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary test subs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PushApi
     */
    public pushControllerTest(options?: AxiosRequestConfig) {
        return PushApiFp(this.configuration).pushControllerTest(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetInformation: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/information`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary gets the values of the tutorial settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetTutorial: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/tutorial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the encrypted config of a client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetWallet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/settings/wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary stores the values of the tutorial settings
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerPostTutorial: async (requestBody: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('settingsControllerPostTutorial', 'requestBody', requestBody)
            const localVarPath = `/settings/tutorial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AccountInformation} accountInformation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerSetInformation: async (accountInformation: AccountInformation, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountInformation' is not null or undefined
            assertParamExists('settingsControllerSetInformation', 'accountInformation', accountInformation)
            const localVarPath = `/settings/information`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountInformation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Stores the encrypted config of a client
         * @param {Wallet} wallet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerSetWallet: async (wallet: Wallet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'wallet' is not null or undefined
            assertParamExists('settingsControllerSetWallet', 'wallet', wallet)
            const localVarPath = `/settings/wallet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(wallet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerGetInformation(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Information>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerGetInformation(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary gets the values of the tutorial settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerGetTutorial(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerGetTutorial(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the encrypted config of a client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerGetWallet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Wallet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerGetWallet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary stores the values of the tutorial settings
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerPostTutorial(requestBody: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerPostTutorial(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {AccountInformation} accountInformation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerSetInformation(accountInformation: AccountInformation, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerSetInformation(accountInformation, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Stores the encrypted config of a client
         * @param {Wallet} wallet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async settingsControllerSetWallet(wallet: Wallet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.settingsControllerSetWallet(wallet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetInformation(options?: any): AxiosPromise<Information> {
            return localVarFp.settingsControllerGetInformation(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary gets the values of the tutorial settings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetTutorial(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.settingsControllerGetTutorial(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the encrypted config of a client
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerGetWallet(options?: any): AxiosPromise<Wallet> {
            return localVarFp.settingsControllerGetWallet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary stores the values of the tutorial settings
         * @param {Array<string>} requestBody 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerPostTutorial(requestBody: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.settingsControllerPostTutorial(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AccountInformation} accountInformation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerSetInformation(accountInformation: AccountInformation, options?: any): AxiosPromise<void> {
            return localVarFp.settingsControllerSetInformation(accountInformation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Stores the encrypted config of a client
         * @param {Wallet} wallet 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        settingsControllerSetWallet(wallet: Wallet, options?: any): AxiosPromise<void> {
            return localVarFp.settingsControllerSetWallet(wallet, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsControllerGetInformation(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsControllerGetInformation(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary gets the values of the tutorial settings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsControllerGetTutorial(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsControllerGetTutorial(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the encrypted config of a client
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsControllerGetWallet(options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsControllerGetWallet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary stores the values of the tutorial settings
     * @param {Array<string>} requestBody 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsControllerPostTutorial(requestBody: Array<string>, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsControllerPostTutorial(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AccountInformation} accountInformation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsControllerSetInformation(accountInformation: AccountInformation, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsControllerSetInformation(accountInformation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Stores the encrypted config of a client
     * @param {Wallet} wallet 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public settingsControllerSetWallet(wallet: Wallet, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).settingsControllerSetWallet(wallet, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StripeApi - axios parameter creator
 * @export
 */
export const StripeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payControllerCreateCheckoutSession: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payControllerHasPay: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payControllerPortal: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/portal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payControllerWebhook: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/stripe/webhook`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StripeApi - functional programming interface
 * @export
 */
export const StripeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StripeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payControllerCreateCheckoutSession(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payControllerCreateCheckoutSession(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payControllerHasPay(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payControllerHasPay(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payControllerPortal(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payControllerPortal(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payControllerWebhook(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payControllerWebhook(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StripeApi - factory interface
 * @export
 */
export const StripeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StripeApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payControllerCreateCheckoutSession(options?: any): AxiosPromise<object> {
            return localVarFp.payControllerCreateCheckoutSession(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payControllerHasPay(options?: any): AxiosPromise<void> {
            return localVarFp.payControllerHasPay(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payControllerPortal(options?: any): AxiosPromise<void> {
            return localVarFp.payControllerPortal(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payControllerWebhook(options?: any): AxiosPromise<void> {
            return localVarFp.payControllerWebhook(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StripeApi - object-oriented interface
 * @export
 * @class StripeApi
 * @extends {BaseAPI}
 */
export class StripeApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public payControllerCreateCheckoutSession(options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).payControllerCreateCheckoutSession(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public payControllerHasPay(options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).payControllerHasPay(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public payControllerPortal(options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).payControllerPortal(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StripeApi
     */
    public payControllerWebhook(options?: AxiosRequestConfig) {
        return StripeApiFp(this.configuration).payControllerWebhook(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TemplatecontractApi - axios parameter creator
 * @export
 */
export const TemplatecontractApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('templateControllerDelete', 'id', id)
            const localVarPath = `/template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerGet: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('templateControllerGet', 'id', id)
            const localVarPath = `/template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {CreateTemplate} createTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerStore: async (createTemplate: CreateTemplate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createTemplate' is not null or undefined
            assertParamExists('templateControllerStore', 'createTemplate', createTemplate)
            const localVarPath = `/template`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {CreateTemplate} createTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerUpdate: async (id: string, createTemplate: CreateTemplate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('templateControllerUpdate', 'id', id)
            // verify required parameter 'createTemplate' is not null or undefined
            assertParamExists('templateControllerUpdate', 'createTemplate', createTemplate)
            const localVarPath = `/template/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createTemplate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TemplatecontractApi - functional programming interface
 * @export
 */
export const TemplatecontractApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TemplatecontractApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateControllerAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContractTemplate>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateControllerAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateControllerDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateControllerDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateControllerGet(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractTemplate>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateControllerGet(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {CreateTemplate} createTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateControllerStore(createTemplate: CreateTemplate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateControllerStore(createTemplate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} id 
         * @param {CreateTemplate} createTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async templateControllerUpdate(id: string, createTemplate: CreateTemplate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.templateControllerUpdate(id, createTemplate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TemplatecontractApi - factory interface
 * @export
 */
export const TemplatecontractApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TemplatecontractApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerAll(options?: any): AxiosPromise<Array<ContractTemplate>> {
            return localVarFp.templateControllerAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.templateControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerGet(id: string, options?: any): AxiosPromise<ContractTemplate> {
            return localVarFp.templateControllerGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {CreateTemplate} createTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerStore(createTemplate: CreateTemplate, options?: any): AxiosPromise<void> {
            return localVarFp.templateControllerStore(createTemplate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {CreateTemplate} createTemplate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        templateControllerUpdate(id: string, createTemplate: CreateTemplate, options?: any): AxiosPromise<void> {
            return localVarFp.templateControllerUpdate(id, createTemplate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TemplatecontractApi - object-oriented interface
 * @export
 * @class TemplatecontractApi
 * @extends {BaseAPI}
 */
export class TemplatecontractApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatecontractApi
     */
    public templateControllerAll(options?: AxiosRequestConfig) {
        return TemplatecontractApiFp(this.configuration).templateControllerAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatecontractApi
     */
    public templateControllerDelete(id: string, options?: AxiosRequestConfig) {
        return TemplatecontractApiFp(this.configuration).templateControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatecontractApi
     */
    public templateControllerGet(id: string, options?: AxiosRequestConfig) {
        return TemplatecontractApiFp(this.configuration).templateControllerGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {CreateTemplate} createTemplate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatecontractApi
     */
    public templateControllerStore(createTemplate: CreateTemplate, options?: AxiosRequestConfig) {
        return TemplatecontractApiFp(this.configuration).templateControllerStore(createTemplate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {CreateTemplate} createTemplate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TemplatecontractApi
     */
    public templateControllerUpdate(id: string, createTemplate: CreateTemplate, options?: AxiosRequestConfig) {
        return TemplatecontractApiFp(this.configuration).templateControllerUpdate(id, createTemplate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TrainingApi - axios parameter creator
 * @export
 */
export const TrainingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Adds a new training
         * @param {Training} training 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerAddTraining: async (training: Training, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'training' is not null or undefined
            assertParamExists('trainingControllerAddTraining', 'training', training)
            const localVarPath = `/training`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(training, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a training
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trainingControllerDelete', 'id', id)
            const localVarPath = `/training/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns the file of a training
         * @param {string} trainingid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerFile: async (trainingid: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trainingid' is not null or undefined
            assertParamExists('trainingControllerFile', 'trainingid', trainingid)
            const localVarPath = `/training/{trainingid}/file`
                .replace(`{${"trainingid"}}`, encodeURIComponent(String(trainingid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns all managed accounts of the logged in user.
         * @param {string} [manager] returns the users of a specific manager
         * @param {string} [all] return all users
         * @param {number} [year] timespawn of the claims
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerGetAllUsers: async (manager?: string, all?: string, year?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/training/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (manager !== undefined) {
                localVarQueryParameter['manager'] = manager;
            }

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a managed accounts of the logged in user.
         * @param {string} userid 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerGetOneUser: async (userid: string, year: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userid' is not null or undefined
            assertParamExists('trainingControllerGetOneUser', 'userid', userid)
            // verify required parameter 'year' is not null or undefined
            assertParamExists('trainingControllerGetOneUser', 'year', year)
            const localVarPath = `/training/users/{userid}`
                .replace(`{${"userid"}}`, encodeURIComponent(String(userid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns object of the logged in user
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerGetOwnUser: async (year: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'year' is not null or undefined
            assertParamExists('trainingControllerGetOwnUser', 'year', year)
            const localVarPath = `/training/own`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary gets the values of the personalised view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerGetView: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/training/view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary stores the values of the personalised view
         * @param {UserView} userView 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerPostView: async (userView: UserView, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userView' is not null or undefined
            assertParamExists('trainingControllerPostView', 'userView', userView)
            const localVarPath = `/training/view`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userView, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload file
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerUploadFile: async (file: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'file' is not null or undefined
            assertParamExists('trainingControllerUploadFile', 'file', file)
            const localVarPath = `/training/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrainingApi - functional programming interface
 * @export
 */
export const TrainingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrainingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Adds a new training
         * @param {Training} training 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerAddTraining(training: Training, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerAddTraining(training, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a training
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerDelete(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns the file of a training
         * @param {string} trainingid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerFile(trainingid: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerFile(trainingid, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns all managed accounts of the logged in user.
         * @param {string} [manager] returns the users of a specific manager
         * @param {string} [all] return all users
         * @param {number} [year] timespawn of the claims
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerGetAllUsers(manager?: string, all?: string, year?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerGetAllUsers(manager, all, year, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns a managed accounts of the logged in user.
         * @param {string} userid 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerGetOneUser(userid: string, year: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerGetOneUser(userid, year, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Returns object of the logged in user
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerGetOwnUser(year: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerGetOwnUser(year, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary gets the values of the personalised view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerGetView(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserView>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerGetView(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary stores the values of the personalised view
         * @param {UserView} userView 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerPostView(userView: UserView, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerPostView(userView, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Upload file
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trainingControllerUploadFile(file: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trainingControllerUploadFile(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TrainingApi - factory interface
 * @export
 */
export const TrainingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrainingApiFp(configuration)
    return {
        /**
         * 
         * @summary Adds a new training
         * @param {Training} training 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerAddTraining(training: Training, options?: any): AxiosPromise<void> {
            return localVarFp.trainingControllerAddTraining(training, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a training
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.trainingControllerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns the file of a training
         * @param {string} trainingid 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerFile(trainingid: string, options?: any): AxiosPromise<void> {
            return localVarFp.trainingControllerFile(trainingid, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns all managed accounts of the logged in user.
         * @param {string} [manager] returns the users of a specific manager
         * @param {string} [all] return all users
         * @param {number} [year] timespawn of the claims
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerGetAllUsers(manager?: string, all?: string, year?: number, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.trainingControllerGetAllUsers(manager, all, year, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns a managed accounts of the logged in user.
         * @param {string} userid 
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerGetOneUser(userid: string, year: number, options?: any): AxiosPromise<object> {
            return localVarFp.trainingControllerGetOneUser(userid, year, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Returns object of the logged in user
         * @param {number} year 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerGetOwnUser(year: number, options?: any): AxiosPromise<object> {
            return localVarFp.trainingControllerGetOwnUser(year, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary gets the values of the personalised view
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerGetView(options?: any): AxiosPromise<UserView> {
            return localVarFp.trainingControllerGetView(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary stores the values of the personalised view
         * @param {UserView} userView 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerPostView(userView: UserView, options?: any): AxiosPromise<void> {
            return localVarFp.trainingControllerPostView(userView, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload file
         * @param {any} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trainingControllerUploadFile(file: any, options?: any): AxiosPromise<FileResponse> {
            return localVarFp.trainingControllerUploadFile(file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrainingApi - object-oriented interface
 * @export
 * @class TrainingApi
 * @extends {BaseAPI}
 */
export class TrainingApi extends BaseAPI {
    /**
     * 
     * @summary Adds a new training
     * @param {Training} training 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingApi
     */
    public trainingControllerAddTraining(training: Training, options?: AxiosRequestConfig) {
        return TrainingApiFp(this.configuration).trainingControllerAddTraining(training, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a training
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingApi
     */
    public trainingControllerDelete(id: string, options?: AxiosRequestConfig) {
        return TrainingApiFp(this.configuration).trainingControllerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns the file of a training
     * @param {string} trainingid 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingApi
     */
    public trainingControllerFile(trainingid: string, options?: AxiosRequestConfig) {
        return TrainingApiFp(this.configuration).trainingControllerFile(trainingid, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns all managed accounts of the logged in user.
     * @param {string} [manager] returns the users of a specific manager
     * @param {string} [all] return all users
     * @param {number} [year] timespawn of the claims
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingApi
     */
    public trainingControllerGetAllUsers(manager?: string, all?: string, year?: number, options?: AxiosRequestConfig) {
        return TrainingApiFp(this.configuration).trainingControllerGetAllUsers(manager, all, year, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns a managed accounts of the logged in user.
     * @param {string} userid 
     * @param {number} year 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingApi
     */
    public trainingControllerGetOneUser(userid: string, year: number, options?: AxiosRequestConfig) {
        return TrainingApiFp(this.configuration).trainingControllerGetOneUser(userid, year, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Returns object of the logged in user
     * @param {number} year 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingApi
     */
    public trainingControllerGetOwnUser(year: number, options?: AxiosRequestConfig) {
        return TrainingApiFp(this.configuration).trainingControllerGetOwnUser(year, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary gets the values of the personalised view
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingApi
     */
    public trainingControllerGetView(options?: AxiosRequestConfig) {
        return TrainingApiFp(this.configuration).trainingControllerGetView(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary stores the values of the personalised view
     * @param {UserView} userView 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingApi
     */
    public trainingControllerPostView(userView: UserView, options?: AxiosRequestConfig) {
        return TrainingApiFp(this.configuration).trainingControllerPostView(userView, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload file
     * @param {any} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrainingApi
     */
    public trainingControllerUploadFile(file: any, options?: AxiosRequestConfig) {
        return TrainingApiFp(this.configuration).trainingControllerUploadFile(file, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary returns own information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerOwn: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary resolves the username of the did
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerResolve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userControllerResolve', 'id', id)
            const localVarPath = `/user/resolve/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary returns own information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerOwn(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerOwn(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary resolves the username of the did
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userControllerResolve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userControllerResolve(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary returns own information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerOwn(options?: any): AxiosPromise<User> {
            return localVarFp.userControllerOwn(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary resolves the username of the did
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userControllerResolve(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.userControllerResolve(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary returns own information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerOwn(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerOwn(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary resolves the username of the did
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public userControllerResolve(id: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).userControllerResolve(id, options).then((request) => request(this.axios, this.basePath));
    }
}


